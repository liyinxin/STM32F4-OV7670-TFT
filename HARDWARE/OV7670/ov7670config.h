#ifndef _OV7670CFG_H
#define _OV7670CFG_H
#include "ov7670.h"	
//////////////////////////////////////////////////////////////////////////////////	 
//本程序参考自网友guanfu_wang代码。
//ALIENTEK战舰STM32开发板
//OV7670 驱动代码	   
//正点原子@ALIENTEK
//技术论坛:www.openedv.com
//修改日期:2012/9/14
//版本：V1.0		    							    							  
//////////////////////////////////////////////////////////////////////////////////
  
//初始化寄存器序列及其对应的值
const u8 ov7670_init_reg_tbl[][2]= 
{   
  {0x3a, 0x04},   // TSLB 行缓冲测试选项 
                        // [7~6] 保留
                        // [5]正负片控制 0：正片 1：负片
                        // [4]UV输出数据 0：通用UV输出 1：固定UV输出（可通过设定 MANU、MANV 为输出）
                        
                        // [3]输出顺序（与COM13[0](0x3D)一起决定）
                        // [3]   COM13[0]
                        //  0       0        YUYV
                        //  0       1        YVYU
                        //  1       0        UYVY
                        //  1       1        VYUY
                        
                        // [2~1] 保留
                        // [0] 自动输出窗口
                        //      0  当分辨率改变时，传感器不自动设置窗口，后端处理器即时调整窗口
                        //      1  当分辨率改变时，传感器立即自动设置窗口，后端处理器必须在下一个Vsync后设整窗口
        {0x40, 0xD0},   // COM15 通用控制15   0XD0:RGB565输出   0X10:一般RGB输出
                        // [7~6] 数据输出范围形式
                        //       0X 范围为 [10]~[F0]
                        //       10 范围为 [01]~[FE]
                        //       11 范围为 [00]~[FF]
                        // [5~4] RGB555/565操作（在COM7[2]=1和COM7[0]=0时有效）
                        //       X0  一般RGB输出
                        //       01  RGB565,并在RGB444[1]为低时有效
                        //       11  RGB555,并在RGB444[1]为低时有效
                        
                        // [3~0] 保留
        {0x12, 0x14},   // COM7 通用控制7
                        // [7] SCCB寄存器复位控制 0 不复位，1 复位
                        // [6] 保留
                        // [5] 输出格式为CIF
                        // [4] 输出格式为QVGA
                        // [3] 输出格式为QCIF
                        // [2] 输出格式为RGB（与[0]一起作用）
                        // [1] 输出彩色条 0 非使能，1使能
                        
                        // [0] 输出格式为RGB（与[2]一起作用）
                        // [2] [0]
                        //  0   0    YUV
                        //  1   0    RGB
                        //  0   1    Bayer RAW
                        //  1   1    Processed Bayer RAW
                        
        {0x32, 0x80},   // HREF 控制
                        // [7~6] HREF边沿数据输出的偏移
                        // [5~3] HREF结束的低3位（高8位在HSTOP寄存器）
                        // [2~0] HREF起始的低3位（高8位在HSTART寄存器）
        {0x17, 0x16},   // HSTART 行输出格式 行帧（HREF列）起始的高8位（低3位在HREF[2~0]）
        {0x18, 0x04},   // HSTOP  行输出格式 行帧（HREF列）结束的高位（低3位在HREF[5~3]）
        {0x19, 0x02},   // VSTRT  场输出格式 场帧（行）起始的高8位（低2位在VREF[1~0]）
        {0x1a, 0x7b},   // VSTOP  场输出格式 场帧（行）结束的高8位（低2位在VREF[3~2]）

        {0x03, 0xC6},   // VREF 场帧控制
                        // [7~6] AGC[9~8]（AGC[7~0]详见 GAIN[7~0]（0X00））
                        // [5~4] 保留
                        // [3~2] VREF 结束的低2位（高8位在 VSTOP[7~0]）
                        // [1~0] VREF 起始的低2位（高8位在 VSTART[7~0]）
        {0x0c, 0x0c},   // COM3 通用控制3
                        // [7] 保留
                        // [6] 输出数据进行 MSB和LSB 交换
                        // [5] 掉电期间输出时钟的状态 0 三态时钟   1 非三态时钟
                        // [4] 掉电期音输出数据的状态 0 三态数据   1 非三态数据
                        // [3] 缩放     0 禁止    1 使能（若设置（COM7[5~3]）成预定模式的像时，然后将COM14[3]设成1 即可手动调节）
                        // [2] DCW控制  0 禁止    1 使能（若设置（COM7[5~3]）成预定模式的像时，然后将COM14[3]设成1 即可手动调节）
                        // [1~0] 保留
        {0x3e, 0x00},   // COM14 通用控制14
                        // [7~5] 保留
                        // [4] DCW 和 PCLK 控制：  0  正常的 PCLK    1 DCW和PCLK由COM12[2~0]及SCALING_PCLK_DIV[3~0]（0X73）控制
                        // [3] 手动缩放控制，应用于预定尺寸（CIF QCIF QVGA）时：0 禁止手动缩放   1 允许手动缩放
                        // [2~0] PCLK分频 （在COM14[4]为1时有效）
                        // 000 /1
                        // 001 /2
                        // 010 /4
                        // 011 /8
                        // 100 /16
                        // 101~111 不允许
        {0x70, 0x00},   // SCALING_XSC 
                        // [7] 测试图案[0]（SCALING_XSC[7]）与测试图案[1]（SCALING_YSC[7]）一起工作
                        //     00 无测试图案输出
                        //     01 移位1
                        //     10 8条颜色条
                        //     11 8条灰度条
                        // [6~0] 水平缩放系数
        {0x71, 0x01},   // SCALING_YSC
                        // [7] 测试图案[0]（SCALING_XSC[7]）与测试图案[1]（SCALING_YSC[7]）一起工作
                        //     00 非测试模式
                        //     01 称位1
                        //     10 8条颜色条
                        //     11 渐变成灰色的彩色条
                        // [6~0] 水平缩放系数
        {0x72, 0x11},   // DCW 控制
                        // [7] 场平均计算控制   0 舍弃   1 四舍五入
                        // [6] 场亚抽样控制     0 舍弃   1 四舍五入
                        // [5~4] 场亚抽样率
                        //       00 无场亚抽样率
                        //       01 场亚抽样2取1
                        //       10 场亚抽样4取1
                        //       11 场亚抽样8取1
                        // [3] 行平均计算控制   0 舍弃   1 四舍五入
                        // [2] 行亚抽样控制     0 舍弃   1 四舍五入
                        // [1~0] 行亚抽样率
                        //       00 无行亚抽样率
                        //       01 行亚抽样2取1
                        //       10 行亚抽样4取1
                        //       11 行亚抽样8取1
        {0x73, 0x09},   // SCALING_PC
                        // [7~4] 保留
                        // [3] DSP缩放时钟分频 旁路控制   0 时钟分频使能     1 时钟分频旁路
                        // [2~0] DSP缩放时钟分频 控制（COM14[3]=1时有效），应与COM14[2~0]设同样的值
                        //    000 一分频
                        //    001 二分频
                        //    010 四分频
                        //    011 八分频
                        //    100 16分频
                        //    101~111 不允许
        {0xa2, 0x02},   // SCALING_PCLK_DELAY 像素始终延迟
                        // [7] 保留
                        // [6~0] 缩放输出延时
        {0x11, 0x03},   // 内部时钟 CLKRC，对于拍照来说，值越大，越清楚，刷屏现像 越不重，摄像时，值过大 会造成跟不上
                        // 00 时，可能是对于 2.8的屏，对于 2.4屏 会出现 7格分屏现象
                        // 值越大时，摄头移动 图像拖尾就会越严重，反之OK
                        // 3值适中，2已有3分屏，0有7分屏，5拖尾重，10已花屏
                        // [7] 保留
                        // [6] 直接使用外部时钟（没有预分频）
                        // [5~0] 内部时钟分频    内部时钟 ＝ 输入时钟/([5~0] + 1)    [5~0] = 00000~11111
        {0x7a, 0x20},   // SLOP 伽马曲线最高段斜率 [7~0] ＝ （0X100 - GAM15[7~0]）* 4/3
        {0x7b, 0x1c},   // GAM1 伽马曲线1节输入结束点0x04输出值
        {0x7c, 0x28},   // GAM2 伽马曲线2节输入结束点0x08输出值
        {0x7d, 0x3c},   // GAM3 伽马曲线3节输入结束点0x10输出值
        {0x7e, 0x55},   // GAM4 伽马曲线4节输入结束点0x20输出值
        {0x7f, 0x68},   // GAM5 伽马曲线5节输入结束点0x28输出值
        {0x80, 0x76},   // GAM6 伽马曲线6节输入结束点0x30输出值
        {0x81, 0x80},   // GAM7 伽马曲线7节输入结束点0x38输出值
        {0x82, 0x88},   // GAM8 伽马曲线8节输入结束点0x40输出值
        {0x83, 0x8f},   // GAM9 伽马曲线9节输入结束点0x48输出值
        {0x84, 0x96},   // GAM10 伽马曲线10节输入结束点0x50输出值
        {0x85, 0xa3},   // GAM11 伽马曲线11节输入结束点0x60输出值
        {0x86, 0xaf},   // GAM12 伽马曲线12节输入结束点0x70输出值
        {0x87, 0xc4},   // GAM13 伽马曲线13节输入结束点0x90输出值
        {0x88, 0xd7},   // GAM14 伽马曲线14节输入结束点0xb0输出值
        {0x89, 0xe8},   // GAM15 伽马曲线15节输入结束点0xd0输出值
        //{0x13, 0xe4},   // COM8 通用控制8
                        // [7] 使能快速AGC/AEC算法
                        // [6] AEC 步长控制 
                        //     0 步长限制与场同步
                        //     1 不限制步长
                        // [5] 条纹滤波器控制 （在 BD50ST（0X9D）或 BD60ST（0X9E）置1时有效） 0 关    1 开
                        // [4~3] 保留
                        // [2] AGC使能
                        // [1] AWB使能
                        // [0] AEC使能
        {0x13, 0xe7},

        {0x00, 0xff},   // AGC 自动增益控制 (值越大 能有效控制 黑像时刷花屏现象)
                        // [7~0] 00~FF   AGC[9~8] 详见 VERF[7~6](0x03)
        {0x10, 0x00},   // AECH 曝光值 
        {0x01, 0x80},   // BLUE 蓝色通道增益 00~FF
        {0x02, 0x80},   // RED  红色通道增益 00~FF
        {0x0d, 0x00},   // COM4 通用控制4
                        // [7~6] 保留
                        // [5~4] 平均选择（与COM17[7~6]一致）
                        //     00 全窗口
                        //     01 半窗口
                        //     10 1/4窗口
                        //     11 1/4窗口
                        // [3~0] 保留
        {0x42, 0x00},   // COM17 通用控制17
                        // [7~6] AEC 窗口必须与 COM4[5~4]设置相同
                        //     00 普通
                        //     01 1/2
                        //     10 1/4
                        //     11 1/4
                        // [5~4] 保留
                        // [3] DSP彩色条控制  0 禁止    1 允许
                        // [2~0] 保留
                  
        {0x14, 0x1a},   // COM9 通用控制9
                        // [7] 保留
                        // [6~4] 自动增益限度－最大AGC值
                        //      000 2X
                        //      001 4X
                        //      010 8X
                        //      011 16X
                        //      100 32X
                        //      101 64X
                        //      110 128X
                        //      111 不允许
                        // [3~1] 保留
                        // [0] 固定AGC/AEC
        {0xa5, 0x05},   // BD50MAX 50HZ条纹滤波器步长限制
        {0xab, 0x07},   // BD60MAX 60HZ条纹滤波器步长限制
        {0x24, 0x75},   // AEW AGC/AEC稳定运行区域上限
        {0x25, 0x63},   // AEB AGC/AEC稳定运行区域下限
        {0x26, 0xA5},   // VPT AGC/AEC快速运行区域
                        // [7~4] 快速调整区上限
                        // [3~0] 快速调整区下限
        {0x9f, 0x78},   // HAECC1 基于直方图的AEC/AGC控制1
        {0xa0, 0x68},   // HAECC2 基于直方图的AEC/AGC控制2
        {0xa1, 0x03},   // RSVD 保留
        {0xa6, 0xdf},   // HAECC3 基于直方图的AEC/AGC控制3
        {0xa7, 0xdf},   // HAECC4 基于直方图的AEC/AGC控制4
        {0xa8, 0xf0},   // HAECC5 基于直方图的AEC/AGC控制5
        {0xa9, 0x90},   // HAECC6 基于直方图的AEC/AGC控制6
        {0xaa, 0x94},   // HAECC7 基于直方图的AEC/AGC控制7
                        //   [7] AEC公式选择  0 基于平均值的AEC算法    1 基于直方图的AEC算法
                        //   [6~0] 保留

        {0x0e, 0x61},   // COM5 通用控制5 保留
        {0x0f, 0x4b},   // COM6 通用控制6
                        // [7] 光学黑行输出选择  
                        //     0  在光学黑行输出禁止HREF
                        //     1  在光学黑行输出使能HREF
                        // 6~2] 保留
                        // [1] 当格式变化时，是否复位所有时序    0 不复位     1 复位
                        // [0] 保留
        {0x16, 0x02},   // RSVD 保留
        {0x1e, 0x27},   // MVFP 水平镜像/场翻转控制  
                        // [7~6] 保留
                        // [5] 水平镜像控制   0 禁止   1 镜像使能
                        // [4] 场翻转控制     0 禁止   1 翻转使能
                        // [3] 保留
                        // [2] 消除黑太阳使能
                        // [1~0] 保留
        {0x21, 0x02},   // ADCCTR1 保留
        {0x22, 0x91},   // ADCCTR2 保留
        {0x29, 0x07},   // ADCCTR3 保留
        {0x33, 0x0b},   // CHLF 感光阵列电流控制 保留
        {0x35, 0x0b},   // RSVD 保留
        {0x37, 0x1d},   // ADC控制 保留
        {0x38, 0x71},   // ACOM ADC和模拟共模控制 保留
        {0x39, 0x2a},   // OFON ADC偏移控制 保留
        {0x3c, 0x78},   // COM12 通用控制12
                        // [7] HERF操作   0 在VSYNC为低时没有HREF     1 HREF总是存在
                        // [6~0] 保留
        {0x4d, 0x40},   // 保留
        {0x4e, 0x20},   // 保留
        {0x69, 0xaa},   // GFIX 固定增益控制
                        // [7~6] Gr通道固定增益值
                        // [5~4] Gb通道固定增益值
                        // [3~2] R通道固定增益值
                        // [1~0] B通道固定增益值
                        //       00 1X
                        //       01 1.25X
                        //       10 1.5X
                        //       11 1.75X
        {0x6b, 0xC0},   // DBLV
                        // [7~6] PLL控制
                        //    00 旁路PLL
                        //    01 输入时钟X4
                        //    10 输入时钟X6
                        //    11 输入时钟X8
                        // [5] 保留
                        // [4] 内部LDO   0 使能    1 旁路
                        // [3~0] 保留
        {0x74, 0x19},   // REG74
                        // [7~5] 保留
                        // [4] 手动数字增益
                        //     0 VREF[7~6]控制数字增益
                        //     1 REG74[1~0]控制数字增益
                        // [3~2] 保留
                        // [1~0] 数字增益手动控制 00 旁路     01 1X     10 2X     11 4X
        {0x8d, 0x4f},   // 保留
        {0x8e, 0x00},   // 保留
        {0x8f, 0x00},   // 保留
        {0x90, 0x00},   // 保留
        {0x91, 0x00},   // 保留
        {0x92, 0x00},   // DM_LNL 空行低8位
        {0x93, 0x00},   // DM_LNH 空行高8位
        
        {0x9a, 0x80},   // 保留
        {0xb0, 0x84},   // 保留
        {0xb1, 0x0c},   // ABLC1
                        // [7~3] 保留
                        // [2] 自动黑电平校正（ABLC）是否使能    0 禁止     1 使能
                        // [1~0] 保留
        {0xb2, 0x0e},   // 保留
        {0xb3, 0x82},   // THL_DLT 自动黑电平校正（ABLC）目标值    值过小时（0x82），对比度显得强，黑画面时，有时会花屏
        {0xb8, 0x0a},   // 保留
        {0x43, 0x14},   // 保留   
        {0x44, 0xf0},   // 保留
        {0x45, 0x34},   // 保留
        {0x46, 0x58},   // 保留
        {0x47, 0x28},   // 保留
        {0x48, 0x3a},   // 保留
        {0x59, 0x88},   // 保留
        {0x5a, 0x88},   // 保留
        {0x5b, 0x44},   // 保留
        {0x5c, 0x67},   // 保留
        {0x5d, 0x49},   // 保留
        {0x5e, 0x0e},   // 保留
        {0x62, 0x00},   // LCC1 镜头补偿选项1 对于光学中心补偿中心的X轴坐标
        {0x63, 0x00},   // LCC2 镜头补偿选项2 对于光学中心补偿中心的Y轴坐标
        {0x64, 0x04},   // LCC3 镜头补偿选项3 G通道的补偿系统（在LCC5[2]=1时有效）
                        //                    R G B通道补偿系数（LCC5[2]=0时有效）
        {0x65, 0x20},   // LCC4 镜头补偿选项4 避免补偿的半径
        {0x66, 0x05},   // LCC5 镜头补偿选项5 
                        // [7~3] 保留
                        // [2] 镱头补偿选择  0 R G B 通道补偿由LCC3（0X64）设定
                        //                   1 R G B 通道补偿由LCC6 LCC3 LCC7 分别设定
        {0x94, 0x04},   // LCC6 镜头校正选项（在LCC5[2]=1有效）
        {0x95, 0x08},   // LCC7 镜头校正选项（在LCC5[2]=1有效）
        {0x6c, 0x0a},   // AWBCTR3 AWB控制3
        {0x6d, 0x55},   // AWBCTR2 AWB控制2
        {0x6e, 0x11},   // AWBCTR1 AWB控制1
        {0x6f, 0x9f},   // AWBCTR0 AWB控制0
        {0x6a, 0x40},   // G通道 AWB增益

        
        {0x15, 0x00},   // COM10 通用控制10
                        // [7] 保留
                        // [6] 由HREF 转到 HSYNC
                        // [5] PCLK输出选择   0 PCLK连续输出    1 PCLK 在行同步期间没输出
                        // [4] PCLK反相
                        // [3] HREF反相
                        // [2] VSYNC选择     0 在PCLK的下降沿VSYNC改变   1 在PCLK的上升沿VSYNC改变
                        // [1] VSYNC 负有效
                        // [0] HSYNC 负有效
        {0x4f, 0x80},   // MTX1 色彩矩阵系数1
        {0x50, 0x80},   // MTX2 色彩矩阵系数2
        {0x51, 0x00},   // MTX3 色彩矩阵系数3
        {0x52, 0x22},   // MTX4 色彩矩阵系数4
        {0x53, 0x5e},   // MTX5 色彩矩阵系数5
        {0x54, 0x80},   // MTX6 色彩矩阵系数6
        {0x55, 0x02},   // BRIGHT 亮度 0x07
        {0x56, 0x60},   // CONTRAS 对比度 值越大，对比度越强 0x50
        {0x57, 0x90},   // CONTRAS-CENTER 对比度中心  change according to Jim's request        
        {0x58, 0x9e},   // MTXS 色彩矩阵系数5~0的符号
                        // [7] 自动对比度中心控制
                        //     0 禁止，中心由寄存器CONTRAST-CENTER(0X57)设置
                        //     1 使能，寄存器CONTRAST-CENTER(0X57)被自动更新
                        // [6] 保留
                        // 5~0] 色彩矩阵系数符号    0 正        1 负
        {0x41, 0x38},   // COM16 通用控制16
                        // [7~6] 保留
                        // [5] 针对 YUV 边缘增强阈值自动调整（调整的结果存在 EDGE[4~0](0X3F)中，
                        //     变化范围由REG75[4~0](0X75)和REG76(0X76)控制）
                        //     0 禁止    1 使能
                        // [4] 降噪阈值自动调整（结果保存在DNSTH(0X4C)，由REG77(0X77)控制范围）
                        //     0 禁止    1 使能
                        // [3] AWB增益使能
                        // [2] 保留
                        // [1] 颜色矩阵系数加倍使能
                        // [0] 保留
                        
        {0x3f, 0x0a},   // 边缘增强调整
                        // [7~5] 保留
                        // [4~0] 边缘增强系数
        {0x75, 0x05},   // REG75 
                        // [7~5] 保留
                        // [4~0] 边缘增强下限
        {0x76, 0xe1},   // REG76
                        // [7] 黑点校正  0 禁止    1 使能
        {0x4c, 0x0F},   // DNSTH 噪声抑制强度
        {0x77, 0x0a},   // REG77 噪声去除偏移
        {0x3d, 0xc2},        // COM13 通用控制13
                        // [7] Gamma 使能
                        // [6] UV 饱和度标准－UV自动调整，结果存放在SATCTR[3~0](0XC9)
                        // [5~1] 保留
                        // [0] UV交换位置（和TSLB[3](0X3A)一起作用）
                        //     TLLB[3]   COM13[0] : 00 YUYV   01 YVYU    10 UYVY     11 VYUY
        {0x4b, 0x09},   // REG4B [7~1] 保留     [0] UV平均使能
        {0xc9, 0x60},   // SATCTR 饱和度控制
                        // [7~4] UV饱和度控制最小值
                        // [3~0] UV饱和度控制结果
        {0x34, 0x11},   // ARBLM 感光阵列参考电压控制 保留
        {0x3b, 0x42},   // COM11 通用控制11
                        // [7] 夜晚模式   0 禁止     1 使能－帧率自动降低，最小侦率在COM11[6~5]中设定，ADVFH 和 ADVHL 自动增加
                        // [6~5] 夜晚模式的最小帧率
                        //       00 和普通模式一样
                        //       01 1/2普通模式
                        //       10 1/4普通模式
                        //       11 1/8普通模式
                        // [4] D56_Auto      0 禁止50/60自动侦测      1 使能50/60自动侦测
                        // [3] 条纹滤波器选择（在COM11[4]= 0 有效）  0  选择BD60ST作为滤波器的值，1 选择BD50ST为滤波器的值
                        // [2] 保留
                        // [1] 曝光时间可以小于条纹滤波器的限制
                        // [0] 保留
        {0xa4, 0x89},   // NT_CTRL
                        // [7~4] 保留
                        // [3] 自动帧率调整   0 双倍曝光时间     1 帧率减半
                        // [2] 保留
                        // [1~0] 帧率调整的分界点  00 在2X增益插入空行，01 4X,  10 8X 
        {0x96, 0x00},   // 保留
        {0x97, 0x30},   // 保留
        {0x98, 0x20},   // 保留
        {0x99, 0x30},   // 保留
        {0x9a, 0x84},   // 保留
        {0x9b, 0x29},   // 保留
        {0x9c, 0x03},   // 保留
        {0x9d, 0x4c},   // BD50ST 50Hz条纹滤波器的值（在COM8[5]=1和COM11[3]=1）
        {0x9e, 0x3f},   // BD60ST 60Hz条纹滤波器的值（在COM8[5]=1和COM11[3]=0）
        {0x78, 0x04},   // 保留        
        {0x79, 0x01},   // 保留
        {0xc8, 0xf0},   // 保留
        {0x09, 0x03},   // COM2 通用控制2
                        // [7~5] 保留
                        // [4] 软件睡眠方式
                        // [3~2] 保留
                        // [1~0] 输出驱动能力  00：1X  01:2X    10:3X     11 4X
        {0x2d, 0x01}    // ADVFL 场中插入空行的低8位（一位表示一行）
}; 

#endif



















